# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package t2tsw;
use base qw(Exporter);
use base qw(DynaLoader);
package t2tswc;
bootstrap t2tsw;
package t2tsw;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package t2tsw;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package t2tsw;

*new_doublep = *t2tswc::new_doublep;
*copy_doublep = *t2tswc::copy_doublep;
*delete_doublep = *t2tswc::delete_doublep;
*doublep_assign = *t2tswc::doublep_assign;
*doublep_value = *t2tswc::doublep_value;
*new_charp = *t2tswc::new_charp;
*copy_charp = *t2tswc::copy_charp;
*delete_charp = *t2tswc::delete_charp;
*charp_assign = *t2tswc::charp_assign;
*charp_value = *t2tswc::charp_value;
*new_doubleArray = *t2tswc::new_doubleArray;
*delete_doubleArray = *t2tswc::delete_doubleArray;
*doubleArray_getitem = *t2tswc::doubleArray_getitem;
*doubleArray_setitem = *t2tswc::doubleArray_setitem;
*new_charpArray = *t2tswc::new_charpArray;
*delete_charpArray = *t2tswc::delete_charpArray;
*charpArray_getitem = *t2tswc::charpArray_getitem;
*charpArray_setitem = *t2tswc::charpArray_setitem;
*malloc_double = *t2tswc::malloc_double;
*calloc_double = *t2tswc::calloc_double;
*realloc_double = *t2tswc::realloc_double;
*free_double = *t2tswc::free_double;
*malloc_charp = *t2tswc::malloc_charp;
*calloc_charp = *t2tswc::calloc_charp;
*realloc_charp = *t2tswc::realloc_charp;
*free_charp = *t2tswc::free_charp;
*bmatrix_double_free = *t2tswc::bmatrix_double_free;
*bmatrix_str_free = *t2tswc::bmatrix_str_free;
*t2tCmdDemux = *t2tswc::t2tCmdDemux;
*t2tCmdOutputDispose = *t2tswc::t2tCmdOutputDispose;
*t2tOutputFileName = *t2tswc::t2tOutputFileName;

############# Class : t2tsw::doubleArrayC ##############

package t2tsw::doubleArrayC;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_doubleArrayC(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_doubleArrayC($self);
        delete $OWNER{$self};
    }
}

*getitem = *t2tswc::doubleArrayC_getitem;
*setitem = *t2tswc::doubleArrayC_setitem;
*cast = *t2tswc::doubleArrayC_cast;
*frompointer = *t2tswc::doubleArrayC_frompointer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::bmatrix_double ##############

package t2tsw::bmatrix_double;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_vals_get = *t2tswc::bmatrix_double_vals_get;
*swig_vals_set = *t2tswc::bmatrix_double_vals_set;
*swig_cols_get = *t2tswc::bmatrix_double_cols_get;
*swig_cols_set = *t2tswc::bmatrix_double_cols_set;
*swig_rows_get = *t2tswc::bmatrix_double_rows_get;
*swig_rows_set = *t2tswc::bmatrix_double_rows_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_bmatrix_double(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_bmatrix_double($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::bmatrix_str ##############

package t2tsw::bmatrix_str;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_vals_get = *t2tswc::bmatrix_str_vals_get;
*swig_vals_set = *t2tswc::bmatrix_str_vals_set;
*swig_cols_get = *t2tswc::bmatrix_str_cols_get;
*swig_cols_set = *t2tswc::bmatrix_str_cols_set;
*swig_rows_get = *t2tswc::bmatrix_str_rows_get;
*swig_rows_set = *t2tswc::bmatrix_str_rows_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_bmatrix_str(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_bmatrix_str($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms ##############

package t2tsw::t2tCmdPrms;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_get_sample_get = *t2tswc::t2tCmdPrms_get_sample_get;
*swig_get_sample_set = *t2tswc::t2tCmdPrms_get_sample_set;
*swig_get_sample_ext_get = *t2tswc::t2tCmdPrms_get_sample_ext_get;
*swig_get_sample_ext_set = *t2tswc::t2tCmdPrms_get_sample_ext_set;
*swig_connect_get = *t2tswc::t2tCmdPrms_connect_get;
*swig_connect_set = *t2tswc::t2tCmdPrms_connect_set;
*swig_start_calibration_get = *t2tswc::t2tCmdPrms_start_calibration_get;
*swig_start_calibration_set = *t2tswc::t2tCmdPrms_start_calibration_set;
*swig_remove_calibration_samples_get = *t2tswc::t2tCmdPrms_remove_calibration_samples_get;
*swig_remove_calibration_samples_set = *t2tswc::t2tCmdPrms_remove_calibration_samples_set;
*swig_calibration_analysis_get = *t2tswc::t2tCmdPrms_calibration_analysis_get;
*swig_calibration_analysis_set = *t2tswc::t2tCmdPrms_calibration_analysis_set;
*swig_event_get = *t2tswc::t2tCmdPrms_event_get;
*swig_event_set = *t2tswc::t2tCmdPrms_event_set;
*swig_save_data_get = *t2tswc::t2tCmdPrms_save_data_get;
*swig_save_data_set = *t2tswc::t2tCmdPrms_save_data_set;
*swig_get_events_data_get = *t2tswc::t2tCmdPrms_get_events_data_get;
*swig_get_events_data_set = *t2tswc::t2tCmdPrms_get_events_data_set;
*swig_get_gazes_data_get = *t2tswc::t2tCmdPrms_get_gazes_data_get;
*swig_get_gazes_data_set = *t2tswc::t2tCmdPrms_get_gazes_data_set;
*swig_clear_data_get = *t2tswc::t2tCmdPrms_clear_data_get;
*swig_clear_data_set = *t2tswc::t2tCmdPrms_clear_data_set;
*swig_get_status_get = *t2tswc::t2tCmdPrms_get_status_get;
*swig_get_status_set = *t2tswc::t2tCmdPrms_get_status_set;
*swig_timestamp_get = *t2tswc::t2tCmdPrms_timestamp_get;
*swig_timestamp_set = *t2tswc::t2tCmdPrms_timestamp_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_timestamp ##############

package t2tsw::t2tCmdPrms_timestamp;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_time_get = *t2tswc::t2tCmdPrms_timestamp_time_get;
*swig_time_set = *t2tswc::t2tCmdPrms_timestamp_time_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_timestamp(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_timestamp($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_get_status ##############

package t2tsw::t2tCmdPrms_get_status;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_get_history_get = *t2tswc::t2tCmdPrms_get_status_get_history_get;
*swig_get_history_set = *t2tswc::t2tCmdPrms_get_status_get_history_set;
*swig_st_matrix_get = *t2tswc::t2tCmdPrms_get_status_st_matrix_get;
*swig_st_matrix_set = *t2tswc::t2tCmdPrms_get_status_st_matrix_set;
*swig_hs_matrix_get = *t2tswc::t2tCmdPrms_get_status_hs_matrix_get;
*swig_hs_matrix_set = *t2tswc::t2tCmdPrms_get_status_hs_matrix_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_get_status(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_get_status($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_clear_data ##############

package t2tsw::t2tCmdPrms_clear_data;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_up_sample_idx_get = *t2tswc::t2tCmdPrms_clear_data_up_sample_idx_get;
*swig_up_sample_idx_set = *t2tswc::t2tCmdPrms_clear_data_up_sample_idx_set;
*swig_up_event_idx_get = *t2tswc::t2tCmdPrms_clear_data_up_event_idx_get;
*swig_up_event_idx_set = *t2tswc::t2tCmdPrms_clear_data_up_event_idx_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_clear_data(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_clear_data($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_get_gazes_data ##############

package t2tsw::t2tCmdPrms_get_gazes_data;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_from_sample_idx_get = *t2tswc::t2tCmdPrms_get_gazes_data_from_sample_idx_get;
*swig_from_sample_idx_set = *t2tswc::t2tCmdPrms_get_gazes_data_from_sample_idx_set;
*swig_start_time_get = *t2tswc::t2tCmdPrms_get_gazes_data_start_time_get;
*swig_start_time_set = *t2tswc::t2tCmdPrms_get_gazes_data_start_time_set;
*swig_gmatrix_get = *t2tswc::t2tCmdPrms_get_gazes_data_gmatrix_get;
*swig_gmatrix_set = *t2tswc::t2tCmdPrms_get_gazes_data_gmatrix_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_get_gazes_data(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_get_gazes_data($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_get_events_data ##############

package t2tsw::t2tCmdPrms_get_events_data;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_from_event_idx_get = *t2tswc::t2tCmdPrms_get_events_data_from_event_idx_get;
*swig_from_event_idx_set = *t2tswc::t2tCmdPrms_get_events_data_from_event_idx_set;
*swig_start_time_get = *t2tswc::t2tCmdPrms_get_events_data_start_time_get;
*swig_start_time_set = *t2tswc::t2tCmdPrms_get_events_data_start_time_set;
*swig_num_matrix_get = *t2tswc::t2tCmdPrms_get_events_data_num_matrix_get;
*swig_num_matrix_set = *t2tswc::t2tCmdPrms_get_events_data_num_matrix_set;
*swig_str_matrix_get = *t2tswc::t2tCmdPrms_get_events_data_str_matrix_get;
*swig_str_matrix_set = *t2tswc::t2tCmdPrms_get_events_data_str_matrix_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_get_events_data(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_get_events_data($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_save_data ##############

package t2tsw::t2tCmdPrms_save_data;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_eye_tracking_fname_get = *t2tswc::t2tCmdPrms_save_data_eye_tracking_fname_get;
*swig_eye_tracking_fname_set = *t2tswc::t2tCmdPrms_save_data_eye_tracking_fname_set;
*swig_events_fname_get = *t2tswc::t2tCmdPrms_save_data_events_fname_get;
*swig_events_fname_set = *t2tswc::t2tCmdPrms_save_data_events_fname_set;
*swig_mode_get = *t2tswc::t2tCmdPrms_save_data_mode_get;
*swig_mode_set = *t2tswc::t2tCmdPrms_save_data_mode_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_save_data(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_save_data($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_event ##############

package t2tsw::t2tCmdPrms_event;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_name_get = *t2tswc::t2tCmdPrms_event_name_get;
*swig_name_set = *t2tswc::t2tCmdPrms_event_name_set;
*swig_start_time_get = *t2tswc::t2tCmdPrms_event_start_time_get;
*swig_start_time_set = *t2tswc::t2tCmdPrms_event_start_time_set;
*swig_duration_get = *t2tswc::t2tCmdPrms_event_duration_get;
*swig_duration_set = *t2tswc::t2tCmdPrms_event_duration_set;
*swig_fields_get = *t2tswc::t2tCmdPrms_event_fields_get;
*swig_fields_set = *t2tswc::t2tCmdPrms_event_fields_set;
*swig_values_get = *t2tswc::t2tCmdPrms_event_values_get;
*swig_values_set = *t2tswc::t2tCmdPrms_event_values_set;
*swig_nfields_get = *t2tswc::t2tCmdPrms_event_nfields_get;
*swig_nfields_set = *t2tswc::t2tCmdPrms_event_nfields_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_event(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_event($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_calibration_analysis ##############

package t2tsw::t2tCmdPrms_calibration_analysis;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_cmatrix_get = *t2tswc::t2tCmdPrms_calibration_analysis_cmatrix_get;
*swig_cmatrix_set = *t2tswc::t2tCmdPrms_calibration_analysis_cmatrix_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_calibration_analysis(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_calibration_analysis($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_remove_calibration_samples ##############

package t2tsw::t2tCmdPrms_remove_calibration_samples;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_rmatrix_get = *t2tswc::t2tCmdPrms_remove_calibration_samples_rmatrix_get;
*swig_rmatrix_set = *t2tswc::t2tCmdPrms_remove_calibration_samples_rmatrix_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_remove_calibration_samples(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_remove_calibration_samples($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_start_calibration ##############

package t2tsw::t2tCmdPrms_start_calibration;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_cmatrix_get = *t2tswc::t2tCmdPrms_start_calibration_cmatrix_get;
*swig_cmatrix_set = *t2tswc::t2tCmdPrms_start_calibration_cmatrix_set;
*swig_load_from_file_get = *t2tswc::t2tCmdPrms_start_calibration_load_from_file_get;
*swig_load_from_file_set = *t2tswc::t2tCmdPrms_start_calibration_load_from_file_set;
*swig_clear_previous_get = *t2tswc::t2tCmdPrms_start_calibration_clear_previous_get;
*swig_clear_previous_set = *t2tswc::t2tCmdPrms_start_calibration_clear_previous_set;
*swig_samples_per_point_get = *t2tswc::t2tCmdPrms_start_calibration_samples_per_point_get;
*swig_samples_per_point_set = *t2tswc::t2tCmdPrms_start_calibration_samples_per_point_set;
*swig_fname_get = *t2tswc::t2tCmdPrms_start_calibration_fname_get;
*swig_fname_set = *t2tswc::t2tCmdPrms_start_calibration_fname_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_start_calibration(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_start_calibration($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_connect ##############

package t2tsw::t2tCmdPrms_connect;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_ip_address_get = *t2tswc::t2tCmdPrms_connect_ip_address_get;
*swig_ip_address_set = *t2tswc::t2tCmdPrms_connect_ip_address_set;
*swig_port_get = *t2tswc::t2tCmdPrms_connect_port_get;
*swig_port_set = *t2tswc::t2tCmdPrms_connect_port_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_connect(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_connect($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_get_sample_ext ##############

package t2tsw::t2tCmdPrms_get_sample_ext;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_smatrix_get = *t2tswc::t2tCmdPrms_get_sample_ext_smatrix_get;
*swig_smatrix_set = *t2tswc::t2tCmdPrms_get_sample_ext_smatrix_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_get_sample_ext(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_get_sample_ext($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmdPrms_get_sample ##############

package t2tsw::t2tCmdPrms_get_sample;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_smatrix_get = *t2tswc::t2tCmdPrms_get_sample_smatrix_get;
*swig_smatrix_set = *t2tswc::t2tCmdPrms_get_sample_smatrix_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmdPrms_get_sample(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmdPrms_get_sample($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : t2tsw::t2tCmd ##############

package t2tsw::t2tCmd;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( t2tsw );
%OWNER = ();
%ITERATORS = ();
*swig_cmd_get = *t2tswc::t2tCmd_cmd_get;
*swig_cmd_set = *t2tswc::t2tCmd_cmd_set;
*swig_prm_get = *t2tswc::t2tCmd_prm_get;
*swig_prm_set = *t2tswc::t2tCmd_prm_set;
sub new {
    my $pkg = shift;
    my $self = t2tswc::new_t2tCmd(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        t2tswc::delete_t2tCmd($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package t2tsw;

*sizeof_double = *t2tswc::sizeof_double;
*sizeof_charp = *t2tswc::sizeof_charp;
*CMD_GET_SAMPLE = *t2tswc::CMD_GET_SAMPLE;
*CMD_GET_SAMPLE_EXT = *t2tswc::CMD_GET_SAMPLE_EXT;
*CMD_DEMO = *t2tswc::CMD_DEMO;
*CMD_CONNECT = *t2tswc::CMD_CONNECT;
*CMD_START_CALIBRATION = *t2tswc::CMD_START_CALIBRATION;
*CMD_ADD_CALIBRATION_POINT = *t2tswc::CMD_ADD_CALIBRATION_POINT;
*CMD_CALIBRATION_ANALYSIS = *t2tswc::CMD_CALIBRATION_ANALYSIS;
*CMD_REMOVE_CALIBRATION_SAMPLES = *t2tswc::CMD_REMOVE_CALIBRATION_SAMPLES;
*CMD_DREW_POINT = *t2tswc::CMD_DREW_POINT;
*CMD_START_TRACKING = *t2tswc::CMD_START_TRACKING;
*CMD_SYNCHRONISE = *t2tswc::CMD_SYNCHRONISE;
*CMD_START_AUTO_SYNC = *t2tswc::CMD_START_AUTO_SYNC;
*CMD_STOP_AUTO_SYNC = *t2tswc::CMD_STOP_AUTO_SYNC;
*CMD_EVENT = *t2tswc::CMD_EVENT;
*CMD_RECORD = *t2tswc::CMD_RECORD;
*CMD_STOP_RECORD = *t2tswc::CMD_STOP_RECORD;
*CMD_GET_EVENTS_DATA = *t2tswc::CMD_GET_EVENTS_DATA;
*CMD_GET_GAZES_DATA = *t2tswc::CMD_GET_GAZES_DATA;
*CMD_SAVE_DATA = *t2tswc::CMD_SAVE_DATA;
*CMD_CLEAR_DATA = *t2tswc::CMD_CLEAR_DATA;
*CMD_CLEAR_HISTORY = *t2tswc::CMD_CLEAR_HISTORY;
*CMD_STOP_TRACKING = *t2tswc::CMD_STOP_TRACKING;
*CMD_DISCONNECT = *t2tswc::CMD_DISCONNECT;
*CMD_GET_STATUS = *t2tswc::CMD_GET_STATUS;
*CMD_CLEANUP = *t2tswc::CMD_CLEANUP;
*CMD_TIMESTAMP = *t2tswc::CMD_TIMESTAMP;
*SAVE_DATA_APPEND = *t2tswc::SAVE_DATA_APPEND;
*SAVE_DATA_TRUNK = *t2tswc::SAVE_DATA_TRUNK;
1;
